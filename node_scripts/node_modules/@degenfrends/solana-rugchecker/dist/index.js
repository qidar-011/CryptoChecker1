"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  HoldersCheckConfig: () => HoldersCheckConfig,
  HoldersChecker: () => HoldersChecker,
  LiquidityCheckConfig: () => LiquidityCheckConfig,
  LiquidityChecker: () => LiquidityChecker,
  MarketdataCheckConfig: () => MarketdataCheckConfig,
  MarketdataChecker: () => MarketdataChecker,
  MetadataCheckConfig: () => MetadataCheckConfig,
  MetadataChecker: () => MetadataChecker,
  RugCheckConfig: () => RugCheckConfig,
  WebsiteChecker: () => WebsiteChecker,
  default: () => SPLRugchecker
});
module.exports = __toCommonJS(src_exports);

// src/checker/metadata-checker.ts
var import_web3 = require("@solana/web3.js");
var import_js = require("@metaplex-foundation/js");
var import_dotenv = require("dotenv");
var import_helius_sdk = require("helius-sdk");
var import_axios = __toESM(require("axios"));

// src/model/result/metadata-check.ts
var _MetadataCheckResult = class _MetadataCheckResult {
  constructor() {
    __publicField(this, "address");
    __publicField(this, "name");
    __publicField(this, "symbol");
    __publicField(this, "imageUrl");
    __publicField(this, "description");
    __publicField(this, "website");
    __publicField(this, "telegram");
    __publicField(this, "twitter");
    __publicField(this, "isMutable");
    __publicField(this, "isMintable");
    __publicField(this, "isFreezable");
    __publicField(this, "isPumpFun");
  }
};
__name(_MetadataCheckResult, "MetadataCheckResult");
var MetadataCheckResult = _MetadataCheckResult;

// src/checker/metadata-checker.ts
var validator = require("validator");
(0, import_dotenv.config)();
var _MetadataChecker = class _MetadataChecker {
  constructor({ solanaRpcEndpoint, heliusApiKey }, connection, metaplex) {
    __publicField(this, "connection");
    __publicField(this, "metaplex");
    __publicField(this, "heliusApiKey");
    if (!solanaRpcEndpoint) {
      solanaRpcEndpoint = String(process.env.SOLANA_RPC_ENDPOINT);
    }
    if (!connection) {
      connection = new import_web3.Connection(solanaRpcEndpoint);
    }
    this.connection = connection;
    if (!metaplex) {
      metaplex = import_js.Metaplex.make(this.connection);
    }
    this.metaplex = metaplex;
    if (heliusApiKey) {
      this.heliusApiKey = heliusApiKey;
    }
  }
  check(tokenAddress) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d;
      const mintAddress = new import_web3.PublicKey(tokenAddress);
      const tokenMetadata = yield this.metaplex.nfts().findByMint({
        mintAddress
      });
      if (tokenMetadata) {
        let metadataCheckResult = this.createRugCheckResult(tokenMetadata);
        if (((_a = tokenMetadata.json) == null ? void 0 : _a.createdOn) !== "https://pump.fun" && this.heliusApiKey && (((_b = tokenMetadata.json) == null ? void 0 : _b.twitter) != "undefined" || ((_c = tokenMetadata.json) == null ? void 0 : _c.website) != "undefined" || ((_d = tokenMetadata.json) == null ? void 0 : _d.telegram) != "undefined")) {
          metadataCheckResult = yield this.getHeliusMetadata(tokenAddress, metadataCheckResult);
        }
        metadataCheckResult.address = tokenAddress;
        return metadataCheckResult;
      }
      return new MetadataCheckResult();
    });
  }
  createRugCheckResult(tokenMetadata) {
    var _a, _b, _c, _d, _e, _f;
    const metadataCheckResult = new MetadataCheckResult();
    metadataCheckResult.name = tokenMetadata.name;
    metadataCheckResult.description = String((_a = tokenMetadata.json) == null ? void 0 : _a.description);
    metadataCheckResult.symbol = tokenMetadata.symbol;
    metadataCheckResult.imageUrl = String((_b = tokenMetadata.json) == null ? void 0 : _b.image);
    metadataCheckResult.telegram = String((_c = tokenMetadata.json) == null ? void 0 : _c.telegram);
    metadataCheckResult.website = String((_d = tokenMetadata.json) == null ? void 0 : _d.website);
    metadataCheckResult.twitter = String((_e = tokenMetadata.json) == null ? void 0 : _e.twitter);
    metadataCheckResult.isMutable = tokenMetadata.isMutable;
    metadataCheckResult.isMintable = tokenMetadata.mint.mintAuthorityAddress !== null;
    metadataCheckResult.isFreezable = tokenMetadata.mint.freezeAuthorityAddress !== null;
    metadataCheckResult.isPumpFun = ((_f = tokenMetadata.json) == null ? void 0 : _f.createdOn) === "https://pump.fun";
    return metadataCheckResult;
  }
  getHeliusMetadata(tokenAddress, token) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const helius = new import_helius_sdk.Helius(this.heliusApiKey);
      try {
        const response = yield helius.rpc.getAsset({
          id: tokenAddress
        });
        const jsonUri = (_a = response.content) == null ? void 0 : _a.json_uri;
        if (jsonUri) {
          const metadataResponse = yield import_axios.default.get(jsonUri, {
            timeout: 3e5,
            responseType: "json"
          });
          if ((_c = (_b = metadataResponse.data) == null ? void 0 : _b.extensions) == null ? void 0 : _c.website) {
            const website = (_e = (_d = metadataResponse.data) == null ? void 0 : _d.extensions) == null ? void 0 : _e.website;
            if (website) {
              const isValidUrl = validator.isURL(website);
              if (isValidUrl) {
                token.website = website;
              }
            }
          }
          if ((_g = (_f = metadataResponse.data) == null ? void 0 : _f.extensions) == null ? void 0 : _g.twitter) {
            const twitter = metadataResponse.data.extensions.twitter;
            if (twitter) {
              token.twitter = twitter;
            }
          }
          if ((_i = (_h = metadataResponse.data) == null ? void 0 : _h.extensions) == null ? void 0 : _i.telegram) {
            const telegram = metadataResponse.data.extensions.telegram;
            if (telegram) {
              token.telegram = telegram;
            }
          }
        }
      } catch (error) {
        console.error("Metadata could not be fetched: ", error);
      }
      return token;
    });
  }
};
__name(_MetadataChecker, "MetadataChecker");
var MetadataChecker = _MetadataChecker;

// src/model/result/rug-check.ts
var _RugCheckResult = class _RugCheckResult {
  constructor() {
    __publicField(this, "address");
    __publicField(this, "metadata");
    __publicField(this, "holders");
    __publicField(this, "liquidity");
    __publicField(this, "marketdata");
  }
};
__name(_RugCheckResult, "RugCheckResult");
var RugCheckResult = _RugCheckResult;

// src/model/config/rug-check.ts
var _RugCheckConfig = class _RugCheckConfig {
  constructor() {
    __publicField(this, "solanaRpcEndpoint");
    __publicField(this, "poolFilePath");
    __publicField(this, "poolAddress");
    __publicField(this, "heliusApiKey");
  }
};
__name(_RugCheckConfig, "RugCheckConfig");
var RugCheckConfig = _RugCheckConfig;

// src/checker/holders-checker.ts
var import_web32 = require("@solana/web3.js");

// src/model/result/holders-check.ts
var _HoldersCheckResult = class _HoldersCheckResult {
  constructor() {
    __publicField(this, "address");
    __publicField(this, "topHolders");
    __publicField(this, "topHoldersPercentage");
    __publicField(this, "raydiumPercentage");
  }
};
__name(_HoldersCheckResult, "HoldersCheckResult");
var HoldersCheckResult = _HoldersCheckResult;

// src/model/result/holder-check.ts
var _HolderCheckResult = class _HolderCheckResult {
  constructor() {
    __publicField(this, "address");
    __publicField(this, "amount");
    __publicField(this, "percentage");
  }
};
__name(_HolderCheckResult, "HolderCheckResult");
var HolderCheckResult = _HolderCheckResult;

// src/checker/holders-checker.ts
var _HoldersChecker = class _HoldersChecker {
  constructor({ solanaRpcEndpoint }, connection) {
    __publicField(this, "connection");
    if (!solanaRpcEndpoint) {
      solanaRpcEndpoint = String(process.env.SOLANA_RPC_ENDPOINT);
    }
    if (!connection) {
      connection = new import_web32.Connection(solanaRpcEndpoint);
    }
    this.connection = connection;
  }
  check(tokenAddress) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      const mintAddress = new import_web32.PublicKey(tokenAddress);
      const totalSupplyResponse = yield this.connection.getTokenSupply(mintAddress);
      const largestHoldersResponse = yield this.connection.getTokenLargestAccounts(mintAddress);
      const totalSupply = (_a = totalSupplyResponse.value) == null ? void 0 : _a.uiAmount;
      if (largestHoldersResponse.value.length === 0 || totalSupply === null || totalSupply <= 0) {
        throw new Error("No holders found");
      }
      let whaleSupply = 0;
      let raydiumSupply = 0;
      let topHolders = [];
      for (const holder of largestHoldersResponse.value) {
        const tokenAccountsResponse = yield this.connection.getParsedAccountInfo(holder.address);
        const walletAddress = (_e = (_d = (_c = (_b = tokenAccountsResponse.value) == null ? void 0 : _b.data) == null ? void 0 : _c.parsed) == null ? void 0 : _d.info) == null ? void 0 : _e.owner;
        if (holder.uiAmount !== null && walletAddress !== null && walletAddress !== "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1") {
          whaleSupply += holder.uiAmount;
          let topHolder = new HolderCheckResult();
          topHolder.address = walletAddress;
          topHolder.amount = holder.uiAmount;
          topHolder.percentage = holder.uiAmount / totalSupply * 100;
          topHolders.push(topHolder);
        } else if (holder.uiAmount !== null && walletAddress === "5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1") {
          raydiumSupply += holder.uiAmount;
        } else {
          console.error("Holder data not correct", holder);
        }
      }
      const raydiumPercentage = raydiumSupply / totalSupply * 100;
      const topHoldersPercentage = whaleSupply / totalSupply * 100;
      const holdersCheckResult = new HoldersCheckResult();
      holdersCheckResult.topHolders = topHolders;
      holdersCheckResult.topHoldersPercentage = topHoldersPercentage;
      holdersCheckResult.raydiumPercentage = raydiumPercentage;
      holdersCheckResult.address = tokenAddress;
      return holdersCheckResult;
    });
  }
};
__name(_HoldersChecker, "HoldersChecker");
var HoldersChecker = _HoldersChecker;

// src/checker/liquidity-checker.ts
var import_web33 = require("@solana/web3.js");
var import_fs = require("fs");
var import_raydium_sdk = require("@raydium-io/raydium-sdk");

// src/model/result/liquidity-check.ts
var _LiquidityCheckResult = class _LiquidityCheckResult {
  constructor() {
    __publicField(this, "address");
    __publicField(this, "isLiquidityLocked");
    __publicField(this, "burnt");
    __publicField(this, "liquidityPoolAddress");
  }
};
__name(_LiquidityCheckResult, "LiquidityCheckResult");
var LiquidityCheckResult = _LiquidityCheckResult;

// src/checker/liquidity-checker.ts
var import_axios2 = __toESM(require("axios"));
var _LiquidityChecker = class _LiquidityChecker {
  constructor({ solanaRpcEndpoint, poolFilePath, poolAddress }, connection) {
    __publicField(this, "connection");
    __publicField(this, "poolFilePath");
    __publicField(this, "poolAddress");
    if (!solanaRpcEndpoint) {
      solanaRpcEndpoint = String(process.env.SOLANA_RPC_ENDPOINT);
    }
    if (!poolFilePath) {
      poolFilePath = String(process.env.POOL_FILE_PATH);
    } else {
      this.poolFilePath = poolFilePath;
    }
    if (poolAddress) {
      this.poolAddress = poolAddress;
    }
    if (!connection) {
      connection = new import_web33.Connection(solanaRpcEndpoint);
    }
    this.connection = connection;
  }
  check(tokenAddress) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f;
      let poolAddress;
      if (this.poolAddress) {
        poolAddress = this.poolAddress;
      } else {
        if (!this.poolFilePath) {
          poolAddress = yield this.getRaydiumPoolAddress(tokenAddress);
        } else {
          poolAddress = yield this.getLiquidityPool(tokenAddress);
        }
      }
      const liquidityCheckResult = new LiquidityCheckResult();
      if (!poolAddress) {
        liquidityCheckResult.liquidityPoolAddress = "";
        return liquidityCheckResult;
      }
      const acc = yield this.connection.getMultipleAccountsInfo([
        new import_web33.PublicKey(poolAddress)
      ]);
      const parsed = acc.map((v) => v ? import_raydium_sdk.LIQUIDITY_STATE_LAYOUT_V4.decode(v.data) : null);
      const lpMint = String((_a = parsed[0]) == null ? void 0 : _a.lpMint);
      let lpReserve = (_c = (_b = parsed[0]) == null ? void 0 : _b.lpReserve.toNumber()) != null ? _c : 0;
      const accInfo = yield this.connection.getParsedAccountInfo(new import_web33.PublicKey(lpMint));
      const mintInfo = (_f = (_e = (_d = accInfo == null ? void 0 : accInfo.value) == null ? void 0 : _d.data) == null ? void 0 : _e.parsed) == null ? void 0 : _f.info;
      lpReserve = lpReserve / Math.pow(10, mintInfo == null ? void 0 : mintInfo.decimals);
      const actualSupply = (mintInfo == null ? void 0 : mintInfo.supply) / Math.pow(10, mintInfo == null ? void 0 : mintInfo.decimals);
      const maxLpSupply = Math.max(actualSupply, lpReserve - 1);
      const burnAmt = lpReserve - actualSupply;
      const burnPct = burnAmt / lpReserve * 100;
      liquidityCheckResult.isLiquidityLocked = burnPct > 95;
      liquidityCheckResult.burnt = burnPct;
      liquidityCheckResult.liquidityPoolAddress = poolAddress;
      liquidityCheckResult.address = tokenAddress;
      return liquidityCheckResult;
    });
  }
  getLiquidityPool(tokenAddress) {
    return __async(this, null, function* () {
      try {
        const data = yield import_fs.promises.readFile(this.poolFilePath, "utf8");
        const allPools = JSON.parse(data);
        const pool = allPools.find((pool2) => pool2.baseMint === tokenAddress || pool2.quoteMint === tokenAddress);
        return pool ? pool.id : "";
      } catch (error) {
        console.error("Error reading or parsing pool file:", error);
        return "";
      }
    });
  }
  getRaydiumPoolAddress(mintAddress) {
    return __async(this, null, function* () {
      try {
        const url = "https://api.geckoterminal.com/api/v2/networks/solana/tokens/" + mintAddress;
        const response = yield import_axios2.default.get(url);
        return response.data.data.relationships.top_pools.data[0].id.replace("solana_", "");
      } catch (error) {
        console.error("Error fetching pool address:", error);
      }
    });
  }
};
__name(_LiquidityChecker, "LiquidityChecker");
var LiquidityChecker = _LiquidityChecker;

// src/model/result/website-check.ts
var _WebsiteCheckResult = class _WebsiteCheckResult {
  constructor() {
    __publicField(this, "address");
    __publicField(this, "createdAt");
    __publicField(this, "registrarUrl");
    __publicField(this, "reseller");
    __publicField(this, "nameServer");
    __publicField(this, "registrantName");
    __publicField(this, "registrantOrganization");
    __publicField(this, "registrantStreet");
    __publicField(this, "registrantCity");
    __publicField(this, "registrantStateProvince");
    __publicField(this, "registrantPostalCode");
    __publicField(this, "registrantCountry");
    __publicField(this, "registrantPhone");
    __publicField(this, "registrantEmail");
  }
};
__name(_WebsiteCheckResult, "WebsiteCheckResult");
var WebsiteCheckResult = _WebsiteCheckResult;

// src/checker/website-checker.ts
var whois = require("whois-json");
var _WebsiteChecker = class _WebsiteChecker {
  constructor() {
  }
  check(website) {
    return __async(this, null, function* () {
      const result = yield function() {
        return __async(this, null, function* () {
          var results = yield whois(website);
          return results;
        });
      }();
      const websiteCheckResult = new WebsiteCheckResult();
      websiteCheckResult.address = website;
      websiteCheckResult.createdAt = new Date(result.creationDate);
      websiteCheckResult.reseller = result.reseller;
      websiteCheckResult.registrarUrl = result.registrarUrl;
      websiteCheckResult.nameServer = result.nameServer;
      websiteCheckResult.registrantName = result.registrantName;
      websiteCheckResult.registrantOrganization = result.registrantOrganization;
      websiteCheckResult.registrantStreet = result.registrantStreet;
      websiteCheckResult.registrantCity = result.registrantCity;
      websiteCheckResult.registrantStateProvince = result.registrantStateProvince;
      websiteCheckResult.registrantPostalCode = result.registrantPostalCode;
      websiteCheckResult.registrantCountry = result.registrantCountry;
      websiteCheckResult.registrantPhone = result.registrantPhone;
      websiteCheckResult.registrantEmail = result.registrantEmail;
      return websiteCheckResult;
    });
  }
};
__name(_WebsiteChecker, "WebsiteChecker");
var WebsiteChecker = _WebsiteChecker;

// src/model/config/metadata-check.ts
var _MetadataCheckConfig = class _MetadataCheckConfig {
  constructor() {
    __publicField(this, "solanaRpcEndpoint");
    __publicField(this, "heliusApiKey");
  }
};
__name(_MetadataCheckConfig, "MetadataCheckConfig");
var MetadataCheckConfig = _MetadataCheckConfig;

// src/model/config/holders-check.ts
var _HoldersCheckConfig = class _HoldersCheckConfig {
  constructor() {
    __publicField(this, "solanaRpcEndpoint");
  }
};
__name(_HoldersCheckConfig, "HoldersCheckConfig");
var HoldersCheckConfig = _HoldersCheckConfig;

// src/model/config/liquidity-check.ts
var _LiquidityCheckConfig = class _LiquidityCheckConfig {
  constructor() {
    __publicField(this, "solanaRpcEndpoint");
    __publicField(this, "poolFilePath");
    __publicField(this, "poolAddress");
  }
};
__name(_LiquidityCheckConfig, "LiquidityCheckConfig");
var LiquidityCheckConfig = _LiquidityCheckConfig;

// src/checker/marketdata-checker.ts
var import_dotenv2 = require("dotenv");
var import_axios3 = __toESM(require("axios"));

// src/model/result/marketdata-check.ts
var _MarketdataCheckResult = class _MarketdataCheckResult {
  constructor() {
    __publicField(this, "address");
    __publicField(this, "priceSol");
    __publicField(this, "priceUsd");
    __publicField(this, "liquidityUsd");
    __publicField(this, "fdv");
    __publicField(this, "volume24h");
    __publicField(this, "volume6h");
    __publicField(this, "volume1h");
    __publicField(this, "volume5m");
    __publicField(this, "priceChange24h");
    __publicField(this, "priceChange6h");
    __publicField(this, "priceChange1h");
    __publicField(this, "priceChange5m");
    __publicField(this, "buys24h");
    __publicField(this, "buys6h");
    __publicField(this, "buys1h");
    __publicField(this, "buys5m");
    __publicField(this, "sells24h");
    __publicField(this, "sells6h");
    __publicField(this, "sells1h");
    __publicField(this, "sells5m");
  }
};
__name(_MarketdataCheckResult, "MarketdataCheckResult");
var MarketdataCheckResult = _MarketdataCheckResult;

// src/checker/marketdata-checker.ts
(0, import_dotenv2.config)();
var _MarketdataChecker = class _MarketdataChecker {
  constructor({}) {
  }
  check(tokenAddress) {
    return __async(this, null, function* () {
      const marketdataResponse = yield import_axios3.default.get("https://api.dexscreener.com/latest/dex/tokens/" + tokenAddress, {
        timeout: 3e5,
        responseType: "json"
      });
      let marketdataResult = this.createMarketdataCheckResult(marketdataResponse.data.pairs[0]);
      marketdataResult.address = tokenAddress;
      return marketdataResult;
    });
  }
  createMarketdataCheckResult(marketdata) {
    const metadataCheckResult = new MarketdataCheckResult();
    metadataCheckResult.priceSol = marketdata.priceNative;
    metadataCheckResult.priceUsd = marketdata.priceUsd;
    metadataCheckResult.liquidityUsd = marketdata.liquidity.usd;
    metadataCheckResult.fdv = marketdata.fdv;
    metadataCheckResult.volume24h = marketdata.volume.h24;
    metadataCheckResult.volume6h = marketdata.volume.h6;
    metadataCheckResult.volume1h = marketdata.volume.h1;
    metadataCheckResult.volume5m = marketdata.volume.m5;
    metadataCheckResult.priceChange24h = marketdata.priceChange.h24;
    metadataCheckResult.priceChange6h = marketdata.priceChange.h6;
    metadataCheckResult.priceChange1h = marketdata.priceChange.h1;
    metadataCheckResult.priceChange5m = marketdata.priceChange.m5;
    metadataCheckResult.buys24h = marketdata.txns.h24.buys;
    metadataCheckResult.buys6h = marketdata.txns.h6.buys;
    metadataCheckResult.buys1h = marketdata.txns.h1.buys;
    metadataCheckResult.buys5m = marketdata.txns.m5.buys;
    metadataCheckResult.sells24h = marketdata.txns.h24.sells;
    metadataCheckResult.sells6h = marketdata.txns.h6.sells;
    metadataCheckResult.sells1h = marketdata.txns.h1.sells;
    metadataCheckResult.sells5m = marketdata.txns.m5.sells;
    return metadataCheckResult;
  }
};
__name(_MarketdataChecker, "MarketdataChecker");
var MarketdataChecker = _MarketdataChecker;

// src/model/config/marketdata-check.ts
var _MarketdataCheckConfig = class _MarketdataCheckConfig {
};
__name(_MarketdataCheckConfig, "MarketdataCheckConfig");
var MarketdataCheckConfig = _MarketdataCheckConfig;

// src/index.ts
var _SPLRugchecker = class _SPLRugchecker {
  constructor({ solanaRpcEndpoint, poolFilePath, poolAddress, heliusApiKey }) {
    __publicField(this, "holdersChecker");
    __publicField(this, "liquidityChecker");
    __publicField(this, "metadataChecker");
    __publicField(this, "marketdataChecker");
    const metadataCheckConfig = {
      solanaRpcEndpoint,
      heliusApiKey
    };
    this.metadataChecker = new MetadataChecker(metadataCheckConfig);
    const holdersCheckConfig = {
      solanaRpcEndpoint
    };
    this.holdersChecker = new HoldersChecker(holdersCheckConfig);
    const liquidityCheckConfig = {
      solanaRpcEndpoint,
      poolFilePath,
      poolAddress
    };
    this.liquidityChecker = new LiquidityChecker(liquidityCheckConfig);
    const marketdataCheckConfig = {};
    this.marketdataChecker = new MarketdataChecker(marketdataCheckConfig);
  }
  check(tokenAddress) {
    return __async(this, null, function* () {
      const [metadataCheckResult, holdersCheckResult, liquidityCheckResult, marketdataCheckResult] = yield Promise.all([
        this.metadataChecker.check(tokenAddress),
        this.holdersChecker.check(tokenAddress),
        this.liquidityChecker.check(tokenAddress),
        this.marketdataChecker.check(tokenAddress)
      ]);
      const rugCheckResult = new RugCheckResult();
      rugCheckResult.metadata = metadataCheckResult;
      rugCheckResult.holders = holdersCheckResult;
      rugCheckResult.liquidity = liquidityCheckResult;
      rugCheckResult.marketdata = marketdataCheckResult;
      return rugCheckResult;
    });
  }
  rugScore(rugCheckResult) {
    let rugScore = 0;
    if (rugCheckResult.metadata.isMintable === true) {
      rugScore += 80;
    }
    if (rugCheckResult.metadata.isFreezable === true) {
      rugScore += 65;
    }
    if (rugCheckResult.metadata.isMutable === true) {
      rugScore += 50;
    }
    if (rugCheckResult.holders.topHoldersPercentage >= 50) {
      rugScore += 80;
    } else if (rugCheckResult.holders.topHoldersPercentage >= 35) {
      rugScore += 60;
    } else if (rugCheckResult.holders.topHoldersPercentage >= 20) {
      rugScore += 50;
    }
    if (rugCheckResult.liquidity.isLiquidityLocked === false) {
      rugScore += 80;
    }
    for (const holder of rugCheckResult.holders.topHolders) {
      if (holder.percentage >= 10) {
        rugScore += 80;
      } else if (holder.percentage >= 7) {
        rugScore += 70;
      } else if (holder.percentage >= 5) {
        rugScore += 50;
      } else if (holder.percentage >= 3) {
        rugScore += 40;
      } else if (holder.percentage >= 2) {
        rugScore += 30;
      } else if (holder.percentage >= 1) {
        rugScore += 20;
      }
    }
    return rugScore;
  }
  isRug(rugCheckResult) {
    const rugScore = this.rugScore(rugCheckResult);
    if (rugScore >= 80) {
      return true;
    }
    return false;
  }
};
__name(_SPLRugchecker, "SPLRugchecker");
var SPLRugchecker = _SPLRugchecker;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HoldersCheckConfig,
  HoldersChecker,
  LiquidityCheckConfig,
  LiquidityChecker,
  MarketdataCheckConfig,
  MarketdataChecker,
  MetadataCheckConfig,
  MetadataChecker,
  RugCheckConfig,
  WebsiteChecker
});
